<?php
 if ( !class_exists('Puc_v4p6_OAuthSignature', false) ): class Puc_v4p6_OAuthSignature { private $consumerKey = ''; private $consumerSecret = ''; public function __construct($consumerKey, $consumerSecret) { $this->consumerKey = $consumerKey; $this->consumerSecret = $consumerSecret; } public function sign($url, $method = 'GET') { $parameters = array(); $query = @parse_url($url, PHP_URL_QUERY); if ( !empty($query) ) { parse_str($query, $parsedParams); if ( is_array($parameters) ) { $parameters = $parsedParams; } $url = substr($url, 0, strpos($url, '?')); } $parameters = array_merge( $parameters, array( 'oauth_consumer_key' => $this->consumerKey, 'oauth_nonce' => $this->nonce(), 'oauth_signature_method' => 'HMAC-SHA1', 'oauth_timestamp' => time(), 'oauth_version' => '1.0', ) ); unset($parameters['oauth_signature']); ksort($parameters); $encodedVerb = urlencode($method); $encodedUrl = urlencode($url); $encodedParams = urlencode(http_build_query($parameters, '', '&')); $stringToSign = $encodedVerb . '&' . $encodedUrl . '&' . $encodedParams; $secret = urlencode($this->consumerSecret) . '&'; $parameters['oauth_signature'] = base64_encode(hash_hmac('sha1', $stringToSign, $secret, true)); return ($url . '?' . http_build_query($parameters)); } private function nonce() { $mt = microtime(); $rand = null; if ( is_callable('random_bytes') ) { try { $rand = random_bytes(16); } catch (Exception $ex) { } } if ( $rand === null ) { $rand = mt_rand(); } return md5($mt . '_' . $rand); } } endif;